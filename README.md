## leetcode-51

本题来自于经典的八皇后问题，这里是N皇后，不仅仅需要计算个数，而且输出皇后摆放的结果。因此：需要解决以下几个问题：

- N皇后问题基本逻辑：回溯法。一旦发生冲突则回溯，从第0行到n-1行遍历，依次判断每行的第0列-N-1列。因此采用用了**递归**的方式来回溯
- 确定是否发生冲突，一是记录对角线特征（主对角线：行-列=定值，从对角线：行+列=定值），二是记录某列是否已被占用
- 记录在哪一行的哪一列存放数据

可能遇到的坑：
- 起初使用数组来记录对角线和列是否被占用，后来发现golang无法初始化非常量长度的数组，于是改用了map
- 最坑的是本地和线上测试都是正确的，但是提交结果不正确，很气，神坑，还没找到原因


## leetcode-52

同上题思路，leetcode直接提交仍显示错误，本地测试和线上测试均无误。

## leetcode-53
在这里使用了分治法，时间复杂度为O(NlogN)，其实有O(N)的解法，这里只是为了练习分治法。注意：

- go里面没有while，统一用for，go里面没有直接判断整数大小的，需要自己实现d
- 注意数组不要越界
- 代码尽量抽象简洁 

## leetcode-54
明确四个值，startX,startY代表每一圈左上角起始位置，endX,endY代表每一圈的右下角结束点。然后一圈一圈环绕，根据这两个点所在的坐标，确定环绕时的横纵坐标。

- 注意横纵坐标的起始位置，> <和>= <=的区别
- 别忘了循环的退出条件，注意每一圈循环起始位置横纵坐标+1，结束位置横纵坐标-1
- 只要startX<endX并且startY<endY，就可以继续环绕的第三步
- 注意输入矩阵为nil的情况

## leetcode-55
始终比较两个值，当前可走的步数和之间的数组里可走的最大步程。如果这个值在未抵达终点前始终大于0，则可以继续。

- 中途一旦出现不能抵达的情况，需要直接返回false.
